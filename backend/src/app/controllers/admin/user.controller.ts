import {
  Context,
  Get,
  Post,
  Put,
  Delete,
  ValidateBody,
  ValidatePathParam,
  HttpResponseOK,
  HttpResponseCreated,
  HttpResponseNotFound,
  HttpResponseNoContent,
} from '@foal/core'
// import { fetchUser, TypeORMStore } from '@foal/typeorm'
import { getRepository } from 'typeorm'

import paginate, { getRange } from './paginate'
import { User, Organization } from '../../entities'

export class UserController {
  repository = getRepository(User)

  @Get('/users')
  async list(ctx: Context) {
    const entityName = 'organizations'
    const query = paginate(ctx.request.query)
    query.relations = ['organizations']
    const [data, total] = await this.repository.findAndCount(query)
    const res = new HttpResponseOK(data)

    const [from, to] = getRange(ctx.request.query.range)

    if (typeof from === 'number' && typeof to === 'number') {
      res.setHeader('Access-Control-Expose-Headers', 'Content-Range')
      res.setHeader('Access-Control-Allow-Credentials', 'true')
      res.setHeader('Content-Range', `${entityName} ${from}-${to}/${total}`)
    }

    return res
  }

  @Get('/users/:id')
  // @ValidatePathParam('id', { type: 'string' })
  async view(ctx: Context) {
    // Get the user with the id given in the URL if it exists.
    const data = await this.repository.findOne(ctx.request.params.id, {
      relations: ['organizations']
    })

    // Return a 404 Not Found response if no such user exists.
    if (!data) {
      return new HttpResponseNotFound()
    }

    return new HttpResponseOK(data)
  }

  @Post('/users')
  @ValidateBody({
    additionalProperties: false,
    properties: {
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      role: { type: 'string' },
      password: { type: 'string' },
      organizationIds: { type: 'array' },
    },
    required: [ 'firstName', 'lastName', 'email', 'role', 'password' ],
    type: 'object',
  })
  async create(ctx: Context) {
    const { firstName, lastName, email, role, password, organizationIds } = ctx.request.body
    const user = await User.registerUser(firstName, lastName, email, role, password)

    // Update Organizations
    if (organizationIds && organizationIds.length) {
      user.organizations = []
      organizationIds.forEach(async id => {
        const org = await getRepository(Organization).findOne(id)
        if (org) {
          user.organizations.push(org)
        }
      })
    } else {
      user.organizations = []
    }

    // Save the user in the database.
    await this.repository.save(user)

    // Return the new user with the id generated by the database. The status is 201.
    return new HttpResponseCreated(user)
  }

  @Put('/users/:id')
  @ValidateBody({
    additionalProperties: false,
    properties: {
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      role: { type: 'string' },
      password: { type: 'string' },
      organizationIds: { type: 'array' },
    },
    type: 'object',
  })
  async update(ctx: Context) {
    // Get the user with the id given in the URL if it exists.
    const data = await this.repository.findOne({
      id: ctx.request.params.id
    })

    // Return a 404 Not Found response if no such user exists.
    if (!data) return new HttpResponseNotFound()

    // Merge data from body
    this.repository.merge(data, ctx.request.body)

    // Retrive specific fields
    const { password, organizationIds } = ctx.request.body

    // Update password if provided
    if (password) {
      await data.setPassword(password)
    }

    // Update Organizations
    if (organizationIds && organizationIds.length) {
      data.organizations = []
      organizationIds.forEach(async id => {
        const org = await getRepository(Organization).findOne(id)
        if (org) {
          data.organizations.push(org)
        }
      })
    } else {
      data.organizations = []
    }

    // Save the user in the database.
    await this.repository.save(data)

    // Return the new user with the id generated by the database. The status is 201.
    return new HttpResponseOK(data)
  }

  @Delete('/users/:id')
  @ValidatePathParam('id', { type: 'string' })
  async delete(ctx: Context) {
    // Get the user with the id given in the URL if it exists.
    const data = await this.repository.findOne({
      id: ctx.request.params.id
    })

    // Return a 404 Not Found response if no such user exists.
    if (!data) {
      return new HttpResponseNotFound()
    }

    // Remove the user from the database.
    await this.repository.remove(data)

    // Returns an successful empty response. The status is 204.
    return new HttpResponseNoContent()
  }
}
